//! Command to fix JUnit XML reports for Trunk.io compatibility.
//!
//! Trunk.io's flaky test detection requires a `file` attribute on `<testcase>` elements
//! to correctly associate failures with source files. Playwright's JUnit reporter
//! outputs `classname` (e.g., "tests/e2e/sync.spec.ts") but not `file`.
//!
//! This command parses the XML, calculates the repository-relative path from the
//! `classname` and the provided `package_dir`, and injects the `file` attribute.
//!
//! It uses a streaming XML editor (quick-xml) to preserve the original structure
//! and formatting as much as possible, avoiding the brittleness of regex replacements.

use anyhow::{Context, Result};
use clap::Parser;
use quick_xml::events::{BytesStart, Event};
use quick_xml::reader::Reader;
use quick_xml::writer::Writer;
use std::fs;
use std::io::Cursor;
use std::path::{Path, PathBuf};

#[derive(Parser, Debug)]
pub(crate) struct FixJunitArgs {
    /// Path to the JUnit XML file generated by the test runner.
    pub junit_path: PathBuf,

    /// Directory of the package (crate) relative to the repository root.
    /// This is used to prefix the `classname` to form a full repo-relative path.
    /// Example: "crates/tasklens-ui"
    pub package_dir: PathBuf,
}

pub(crate) fn run(args: FixJunitArgs) -> Result<()> {
    if !args.junit_path.exists() {
        return Err(anyhow::anyhow!("File not found: {:?}", args.junit_path));
    }

    let xml_content = fs::read_to_string(&args.junit_path)
        .with_context(|| format!("Failed to read {:?}", args.junit_path))?;

    let fixed_xml = transform_junit(&xml_content, &args.package_dir)?;

    // Only write back to disk if the content actually changed to verify idempotency
    // and avoid unnecessary file touches.
    if fixed_xml != xml_content {
        fs::write(&args.junit_path, fixed_xml)
            .with_context(|| format!("Failed to write to {:?}", args.junit_path))?;
        println!(
            "Successfully fixed {:?} for Trunk.io compatibility.",
            args.junit_path
        );
    } else {
        println!("No changes needed for {:?}.", args.junit_path);
    }

    Ok(())
}

/// Transforms the JUnit XML content by injecting `file` attributes into `testcase` elements.
///
/// This function uses `quick-xml` to stream events from a reader to a writer,
/// intercepting `testcase` tags to modify them.
fn transform_junit(content: &str, package_dir: &Path) -> Result<String> {
    let mut reader = Reader::from_str(content);
    // Disable trimming to preserve original whitespace formatting
    reader.config_mut().trim_text(false);

    let mut writer = Writer::new(Cursor::new(Vec::new()));
    let mut buf = Vec::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Eof) => break,
            // Handle both Empty (<tag />) and Start (<tag>...) events for testcases
            Ok(Event::Empty(e)) => {
                let mut elem = e.clone();
                if elem.name().as_ref() == b"testcase" {
                    process_testcase(&mut elem, package_dir)?;
                }
                writer.write_event(Event::Empty(elem))?;
            }
            Ok(Event::Start(e)) => {
                let mut elem = e.clone();
                if elem.name().as_ref() == b"testcase" {
                    process_testcase(&mut elem, package_dir)?;
                }
                writer.write_event(Event::Start(elem))?;
            }
            // Pass through all other events (End, Text, Comment, etc.) unchanged
            Ok(e) => {
                writer.write_event(e)?;
            }
            Err(e) => return Err(anyhow::anyhow!("XML parse error: {:?}", e)),
        }
        buf.clear();
    }

    let result = writer.into_inner().into_inner();
    Ok(String::from_utf8(result)?)
}

/// Modifies a `<testcase>` element to add the `file` attribute if missing.
///
/// It constructs the `file` path by joining `package_dir` with the `classname` attribute.
fn process_testcase(elem: &mut BytesStart, package_dir: &Path) -> Result<()> {
    // If 'file' attribute already exists, we assume the report is already correct
    if elem.try_get_attribute("file")?.is_some() {
        return Ok(());
    }

    // Playwright puts the relative test file path in the 'classname' attribute.
    // E.g. classname="tests/e2e/login.spec.ts"
    if let Some(attr) = elem.try_get_attribute("classname")? {
        let classname = String::from_utf8(attr.value.to_vec())?;

        // Trunk expects paths relative to the repo root.
        // We assume `classname` is relative to `package_dir`.
        let repo_relative_path = package_dir.join(&classname);

        let path_str = repo_relative_path
            .to_str()
            .ok_or_else(|| anyhow::anyhow!("Invalid unicode path: {:?}", repo_relative_path))?;

        elem.push_attribute(("file", path_str));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_adds_file_attribute() {
        let input = r#"<testcase name="Alice" classname="tests/e2e/sync.spec.ts" time="1.0" />"#;
        let package_dir = PathBuf::from("crates/tasklens-ui");

        let output = transform_junit(input, &package_dir).unwrap();

        assert!(output.contains(r#"file="crates/tasklens-ui/tests/e2e/sync.spec.ts""#));
    }

    #[test]
    fn test_skips_existing_file_attribute() {
        let input = r#"<testcase name="Skip" classname="foo.ts" file="existing.ts" />"#;
        let package_dir = PathBuf::from("crates/tasklens-ui");

        let output = transform_junit(input, &package_dir).unwrap();

        assert!(output.contains(r#"file="existing.ts""#));
        assert!(!output.contains(r#"file="crates/tasklens-ui/foo.ts""#));
    }

    #[test]
    fn test_handles_missing_classname() {
        let input = r#"<testcase name="NoClass" time="1.0" />"#;
        let package_dir = PathBuf::from("crates/tasklens-ui");

        let output = transform_junit(input, &package_dir).unwrap();

        // Should not crash and not add file attribute
        assert!(!output.contains("file="));
    }

    #[test]
    fn test_preserves_structure() {
        let input = r#"<testsuite><testcase name="A" classname="a.ts"></testcase></testsuite>"#;
        let package_dir = PathBuf::from("pkg");

        let output = transform_junit(input, &package_dir).unwrap();

        assert!(output.starts_with("<testsuite>"));
        assert!(output.contains(r#"file="pkg/a.ts""#));
        assert!(output.ends_with("</testsuite>"));
    }
}
